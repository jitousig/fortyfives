import { AnyFn, State, Game, Plugin, Ctx } from '../types';
interface PluginOpts {
    game: Game;
    isClient?: boolean;
}
/**
 * Allow plugins to intercept actions and process them.
 */
export declare const ProcessAction: (state: State<any, Ctx>, action: {
    type: "PLUGIN";
    payload: {
        type: string;
        args: any;
        playerID: string;
    };
}, opts: PluginOpts) => State<any, Ctx>;
/**
 * The API's created by various plugins are stored in the plugins
 * section of the state object:
 *
 * {
 *   G: {},
 *   ctx: {},
 *   plugins: {
 *     plugin-a: {
 *       data: {},  // this is generated by the plugin at Setup / Flush.
 *       api: {},   // this is ephemeral and generated by Enhance.
 *     }
 *   }
 * }
 *
 * This function takes these API's and stuffs them back into
 * ctx for consumption inside a move function or hook.
 */
export declare const EnhanceCtx: (state: Pick<State<any, Ctx>, "G" | "ctx" | "plugins">) => Ctx;
/**
 * Applies the provided plugins to the given move / flow function.
 *
 * @param {function} fn - The move function or trigger to apply the plugins to.
 * @param {object} plugins - The list of plugins.
 */
export declare const FnWrap: (fn: AnyFn, plugins: Plugin<any, any, any>[]) => (G: any, ctx: Ctx, ...args: any[]) => any;
/**
 * Allows the plugin to generate its initial state.
 */
export declare const Setup: (state: Pick<State<any, Ctx>, "G" | "ctx" | "plugins">, opts: PluginOpts) => Pick<State<any, Ctx>, "G" | "ctx" | "plugins">;
/**
 * Invokes the plugin before a move or event.
 * The API that the plugin generates is stored inside
 * the `plugins` section of the state (which is subsequently
 * merged into ctx).
 */
export declare const Enhance: (state: State<any, Ctx>, opts: PluginOpts & {
    playerID: string;
}) => State<any, Ctx>;
/**
 * Allows plugins to update their state after a move / event.
 */
export declare const Flush: (state: State<any, Ctx>, opts: PluginOpts) => State<any, Ctx>;
/**
 * Allows plugins to indicate if they should not be materialized on the client.
 * This will cause the client to discard the state update and wait for the
 * master instead.
 */
export declare const NoClient: (state: State<any, Ctx>, opts: PluginOpts) => boolean;
export {};
